// Logging Library
const winston = require('winston');

module.exports = function (uname, pwd, realm, host, verboseLevel) {

    const pve_utils = require('./pve-curl')(verboseLevel);

    var _loggerLevel = 'error';

    // Logging levels defined as of `RFC5424`
    // emerg: 0,  alert: 1,  crit: 2,  error: 3, 
    // warning: 4, notice: 5, info: 6, debug: 7
    switch (parseInt(verboseLevel)) {
        case 0: { _loggerLevel = 'error'; break; }
        case 1: { _loggerLevel = 'warning'; break; }
        case 2: { _loggerLevel = 'info'; break; }
        case 3: { _loggerLevel = 'debug'; break; }
        default: { _loggerLevel = 'error'; break; }
    }

    const _logger = winston.createLogger({
        levels: winston.config.syslog.levels,
        transports: [new winston.transports.Console({
            level: _loggerLevel,
            format: winston.format.combine(winston.format.colorize(), winston.format.simple())
        })]
    });

    if (verboseLevel === 'undefined' || verboseLevel === null || verboseLevel < 0) {
        _logger.pause();
    }

    // Authentication Info
    var _pveAuthInfo = {};
    _pveAuthInfo.apiToken = null;
    _pveAuthInfo.username = `${uname}@${realm}`;
    _pveAuthInfo.password = pwd;
    _pveAuthInfo.realm = realm;
    _pveAuthInfo.host = host;
    _pveAuthInfo.endpoint = `https://${_pveAuthInfo.host}:8006/api2/json`;

    var _pveTicket = {};
    _pveTicket.ticket = '';
    _pveTicket.csrfPreventionToken = '';
    _pveTicket.timeStamp = 0;

    // `_standaloneFlag` tells whether the ticket is generated by the main module(`pve-api.js`)[$_standaloneFlag=false]
    // or by the standalone module(`pve-storage/api.js`)[$_standaloneFlag=true]
    // Default is $_standaloneFlag=true
    var _standaloneFlag = true;

    let _GenerateNewTicket = async () => {
        if (_standaloneFlag) {
            if (_pveTicket.timeStamp + 7200 < new Date().getTime()) {
                var response = await pve_utils.PveCurl.Post(
                    `${_pveAuthInfo.endpoint}/access/ticket`,
                    {
                        username: _pveAuthInfo.username,
                        password: _pveAuthInfo.password
                    },
                    "",
                    ""
                );
                var resBody = null;

                if (response.body !== 'undefined' && response.body !== null) {
                    var body = response.body;
                    if (typeof (body) === 'string') {
                        resBody = JSON.parse(body);
                    } else {
                        resBody = body;
                    }
                }
                var ticketData = resBody.data;
                _pveTicket.csrfPreventionToken = ticketData.CSRFPreventionToken;
                _pveTicket.ticket = ticketData.ticket;
                _pveTicket.timeStamp = new Date().getTime();
            }
        }
    };

    let Module = {
        /**
         * @access private
         * @param {object} ticket 
         * @description Sets the ticket to be used to make request to the API.
         * 
         *              __Used only by module `pve-api.js`.__
         * 
         *              __Use of this function is highly discouraged!__
         */
        _SetTicket: function (ticket) {
            _pveTicket.csrfPreventionToken = ticket.csrfPreventionToken;
            _pveTicket.ticket = ticket.ticket;
            _pveTicket.timeStamp = ticket.timeStamp;
            _standaloneFlag = false;
        },

        SetSslVerifyPeer: (sslVerifyPeer) => {
            pve_utils.PveCurl.SetSslVerifyPeer(sslVerifyPeer);
        },

        SetSslVerifyHost: (sslVerifyHost) => {
            pve_utils.PveCurl.SetSslVerifyHost(sslVerifyHost);
        },

        Get: async function (poolid) {
            await _GenerateNewTicket();

            var reqBody = {
                poolid: poolid
            };

            return await pve_utils.PveCurl.Get(
                `${_pveAuthInfo.endpoint}/pools`,
                reqBody,
                {},
                { PVEAuthCookie: _pveTicket.ticket }
            );
        },

        Post: async function (params) {
            await _GenerateNewTicket();

            var reqBody = params;

            return await pve_utils.PveCurl.Post(
                `${_pveAuthInfo.endpoint}/pools`,
                reqBody,
                { CSRFPreventionToken: _pveTicket.csrfPreventionToken },
                { PVEAuthCookie: _pveTicket.ticket }
            )
        },

        PoolID: function (poolid) {
            return {
                Get: async function () {
                    await _GenerateNewTicket();

                    return await pve_utils.PveCurl.Get(
                        `${_pveAuthInfo.endpoint}/pools/${poolid}`,
                        {},
                        {},
                        { PVEAuthCookie: _pveTicket.ticket }
                    );
                },

                Put: async function (params) {
                    await _GenerateNewTicket();

                    return await pve_utils.PveCurl.Put(
                        `${_pveAuthInfo.endpoint}/pools/${poolid}`,
                        params,
                        { CSRFPreventionToken: _pveTicket.csrfPreventionToken },
                        { PVEAuthCookie: _pveTicket.ticket }
                    );
                },

                Delete: async function (params) {
                    await _GenerateNewTicket();

                    return await pve_utils.PveCurl.Delete(
                        `${_pveAuthInfo.endpoint}/pools/${poolid}`,
                        params,
                        { CSRFPreventionToken: _pveTicket.csrfPreventionToken },
                        { PVEAuthCookie: _pveTicket.ticket }
                    );
                }
            }
        }
    };

    return Module;
};